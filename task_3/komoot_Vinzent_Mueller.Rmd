---
title: "Komoot Retention Task"
author: "Vinzent MÃ¼ller"

output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries

```{r, message=FALSE}
library(data.table)
library(fasttime)
library(sp)
library(rworldmap)
library(ggplot2)
```

Read the data set

```{r}
wd = "/home/vinzent/Documents/r_scrips"
setwd(wd)

events = fread("tour-events.csv", sep = ',')
```

Remove missing values, change date columns to appropriate data type

```{r}
events = events[complete.cases(events), ]

events[,timestamp := fastPOSIXct(timestamp)]
```

Multiple rows and dates are present for each user. Format changed to one line per user

 * first date of usage
 * last date of usage
 * coordinates of first usage are used for a user's home country
 
```{r}
users = events[ , .( firstdate = min(timestamp), lastdate = max(timestamp), long = longitude[which.min(timestamp)], lat = latitude[which.min(timestamp)]), by = user]
```

Yearly cohorts will be used, so we add a year column

```{r}
users[ , firstyear := as.integer(format(firstdate, format = "%Y"))]
```

```{r}
summary(users)
```

Get country code for the given coordinates. Function taken from SO:

```{r}
coords2country = function(points)
{  
  countriesSP <- getMap(resolution='low')
  # convert our list of points to a SpatialPoints object

  #setting CRS directly to that from rworldmap
  pointsSP = SpatialPoints(points, proj4string=CRS(proj4string(countriesSP)))  

  # use 'over' to get indices of the Polygons object containing each point 
  indices = over(pointsSP, countriesSP)
  
  # return the ADMIN names of each country
  indices$ADMIN  
}
```

Add column containing the country code
```{r}
users[ , country := coords2country(users[ , .(long, lat)])]
```

Only a few countries with sufficient data, discard the others

```r
table(users[, .(country)])
```

```{r}
users = users[country %in% c("Austria", "Germany", "Switzerland", "United States of America"), ]

users[ , country := droplevels(country)]
```

The same holds for the cohort years

```r
table(users[, .(country, firstyear)])
```

```{r}
users = users[firstyear >= 2012 & !(country == "United States of America" & firstyear < 2015)]
```

Calculate user's age in months

```{r}
# (sloppy) month calculation
users[ , tenureMonths := as.integer(difftime(lastdate, firstdate, units = 'days')/30)]

users[ , ageMonths := as.integer(difftime(max(lastdate), firstdate, units = 'days')/30)]
```

Create a row for each month a user has been active

```{r}
months = data.frame(month = seq(0:max(users[, ageMonths]))-1)

users = data.table(merge(data.frame(users), months, by = NULL))

# crop months that a user cannot have lived through
users = users[ month <= ageMonths,]
```

Flag a user as active

```{r}
users[ , active := ifelse(month <= tenureMonths, 1, 0)]
```

Create the actual cohorts table

```{r}
cohorts = users[ , .( nActive = sum(active)), by = .(country, month, firstyear)]

years = users[ , .(total = length(unique(user))), by = .(country, firstyear)]

cohorts = merge(years, cohorts, by = c("firstyear", "country"))

cohorts
```

Add % active in addition to N active, change year data type
```{r}
cohorts[ , percentActive := nActive/total]

cohorts[,firstyear := as.factor(firstyear)]
```

Data preparation is done. From here on, retention heatmaps or other plots can be generated:

```{r}
ggplot(cohorts, aes(month, firstyear)) + geom_tile(aes(fill = percentActive), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue") + facet_wrap( ~country, scales = "free") + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0), limits = rev(levels(cohorts$firstyear))) + theme_bw()
```

Also, we can create a wide table for use in reports

```{r}
cohort_table = reshape(cohorts[, .(country, firstyear, month, percentActive)], idvar = c("country" ,"firstyear"), timevar = "month", direction = "wide")

options(digits=2)
cohort_table[country == "Germany", 1:6]
```